{
  "paragraphs": [
    {
      "text": "%md\n# Chargement des fichiers CSV dans des DataFrames\n\nUtilisez `sqlContext.read` et le module Spark CSV pour charger les fichiers CSV :\n\n- le fichier des artistes et groupes : `/data/music/performers.csv`\n- le fichier des albums : `/data/music/albums.csv`\n- le fichier des notes : `/data/music/artists_ratings.csv`\n\nCes fichiers contiennent un header et utilisent le délimiteur `,`.\n\nStockez ces DataFrames dans des variables `performersDF`, `albumsDF` et `ratingsDF`.\n\nDocumentation du module Spark CSV : [https://github.com/databricks/spark-csv](https://github.com/databricks/spark-csv)",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448372318348_150128478",
      "id": "20151124-133838_1627879838",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eChargement des fichiers CSV dans des DataFrames\u003c/h1\u003e\n\u003cp\u003eUtilisez \u003ccode\u003esqlContext.read\u003c/code\u003e et le module Spark CSV pour charger les fichiers CSV :\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ele fichier des artistes et groupes : \u003ccode\u003e/data/music/performers.csv\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ele fichier des albums : \u003ccode\u003e/data/music/albums.csv\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ele fichier des notes : \u003ccode\u003e/data/music/artists_ratings.csv\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCes fichiers contiennent un header et utilisent le délimiteur \u003ccode\u003e,\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eStockez ces DataFrames dans des variables \u003ccode\u003eperformersDF\u003c/code\u003e, \u003ccode\u003ealbumsDF\u003c/code\u003e et \u003ccode\u003eratingsDF\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eDocumentation du module Spark CSV : \u003ca href\u003d\"https://github.com/databricks/spark-csv\"\u003ehttps://github.com/databricks/spark-csv\u003c/a\u003e\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 1:38:38 PM",
      "dateStarted": "Nov 24, 2015 5:42:44 PM",
      "dateFinished": "Nov 24, 2015 5:42:44 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Chargement des fichiers CSV dans des dataframes",
      "text": "//val albumsDF \u003d sqlContext.read\n// ...\n  \n//val performersDF \u003d sqlContext.read\n// ...\n\n//val ratingsDF \u003d sqlContext.read\n// ...",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/scala",
        "title": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448275074314_-816938906",
      "id": "20151123-103754_1903829939",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 10:37:54 AM",
      "dateStarted": "Nov 24, 2015 5:42:44 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n## Mise en cache\n\nSpark ne conserve pas les données intermédiaires en mémoire : lorsqu\u0027on exécute une *action*, l\u0027ensemble des *transformations* sont (ré-)exécutées, y compris le chargement des données.\n\nPour éviter de relire à chaque fois les fichiers CSV, mettez-les en cache avec la méthode `persist` ou `cache`.",
      "dateUpdated": "Nov 24, 2015 5:48:17 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448385003844_-1690538061",
      "id": "20151124-171003_1047834612",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch2\u003eMise en cache\u003c/h2\u003e\n\u003cp\u003eSpark ne conserve pas les données intermédiaires en mémoire : lorsqu\u0027on exécute une \u003cem\u003eaction\u003c/em\u003e, l\u0027ensemble des \u003cem\u003etransformations\u003c/em\u003e sont (ré-)exécutées, y compris le chargement des données.\u003c/p\u003e\n\u003cp\u003ePour éviter de relire à chaque fois les fichiers CSV, mettez-les en cache avec la méthode \u003ccode\u003epersist\u003c/code\u003e ou \u003ccode\u003ecache\u003c/code\u003e.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 5:10:03 PM",
      "dateStarted": "Nov 24, 2015 5:48:16 PM",
      "dateFinished": "Nov 24, 2015 5:48:16 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "// TODO",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448382787177_-74531908",
      "id": "20151124-163307_1507273121",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 24, 2015 4:33:07 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Affichage des artistes et groupes\n\nUtilisez `z.show` pour afficher le DataFrame des artistes et des groupes (`performersDF`). Visualisez les données.\n\nRemarquez que les styles sont indiqués sous forme d\u0027une chaine de caractères. Il nous faudra *parser* cette chaine.",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorHide": true,
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448373283699_-1677278321",
      "id": "20151124-135443_1839134559",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eAffichage des artistes et groupes\u003c/h1\u003e\n\u003cp\u003eUtilisez \u003ccode\u003ez.show\u003c/code\u003e pour afficher le DataFrame des artistes et des groupes (\u003ccode\u003eperformersDF\u003c/code\u003e). Visualisez les données.\u003c/p\u003e\n\u003cp\u003eRemarquez que les styles sont indiqués sous forme d\u0027une chaine de caractères. Il nous faudra \u003cem\u003eparser\u003c/em\u003e cette chaine.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 1:54:43 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "les artistes (table)",
      "text": "// TODO",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [
            {
              "name": "name",
              "index": 0.0,
              "aggr": "sum"
            }
          ],
          "values": [
            {
              "name": "country",
              "index": 1.0,
              "aggr": "sum"
            }
          ],
          "groups": [],
          "scatter": {
            "xAxis": {
              "name": "name",
              "index": 0.0,
              "aggr": "sum"
            },
            "yAxis": {
              "name": "country",
              "index": 1.0,
              "aggr": "sum"
            }
          }
        },
        "editorMode": "ace/mode/scala",
        "title": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448276906954_1909891149",
      "id": "20151123-110826_345483550",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 11:08:26 AM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:46 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Affichage des albums\n\nUtilisez `z.show` pour afficher le DataFrame des albums (`albumsDF`). Visualisez les données.",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448372580060_972319908",
      "id": "20151124-134300_1599120134",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eAffichage des albums\u003c/h1\u003e\n\u003cp\u003eUtilisez \u003ccode\u003ez.show\u003c/code\u003e pour afficher le DataFrame des albums (\u003ccode\u003ealbumsDF\u003c/code\u003e). Visualisez les données.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 1:43:00 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Les albums (table)",
      "text": "// TODO",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [
            {
              "name": "performer",
              "index": 0.0,
              "aggr": "sum"
            }
          ],
          "values": [
            {
              "name": "title",
              "index": 1.0,
              "aggr": "sum"
            }
          ],
          "groups": [],
          "scatter": {
            "xAxis": {
              "name": "performer",
              "index": 0.0,
              "aggr": "sum"
            },
            "yAxis": {
              "name": "title",
              "index": 1.0,
              "aggr": "sum"
            }
          }
        },
        "editorMode": "ace/mode/scala",
        "title": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448276848959_-522784201",
      "id": "20151123-110728_663291060",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 11:07:28 AM",
      "dateStarted": "Nov 24, 2015 5:42:46 PM",
      "dateFinished": "Nov 24, 2015 5:42:46 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Nombre d\u0027albums par année\n\nCréez un DataFrame contenant le nombre d\u0027albums par année et stockez-le dans une variable `countAlbumsPerYearDF`.\n\nVous pouvez vous aider de la documentation de l\u0027API : [http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame)\n\nUtilisez `z.show` pour afficher les données **sous forme d\u0027histogramme**.\n\nRemarquez qu\u0027une année est incorrecte. Filtrez cette valeur dans votre DataFrame et vérifiez le résultat.",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448373553133_541182192",
      "id": "20151124-135913_877803699",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eNombre d\u0027albums par année\u003c/h1\u003e\n\u003cp\u003eCréez un DataFrame contenant le nombre d\u0027albums par année et stockez-le dans une variable \u003ccode\u003ecountAlbumsPerYearDF\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eVous pouvez vous aider de la documentation de l\u0027API : \u003ca href\u003d\"http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame\"\u003ehttp://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eUtilisez \u003ccode\u003ez.show\u003c/code\u003e pour afficher les données \u003cstrong\u003esous forme d\u0027histogramme\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eRemarquez qu\u0027une année est incorrecte. Filtrez cette valeur dans votre DataFrame et vérifiez le résultat.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 1:59:13 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "nombre d\u0027albums par année (Histogramme)",
      "text": "// TODO",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "multiBarChart",
          "height": 300.0,
          "optionOpen": false,
          "keys": [
            {
              "name": "year",
              "index": 0.0,
              "aggr": "sum"
            }
          ],
          "values": [
            {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          ],
          "groups": [],
          "scatter": {
            "xAxis": {
              "name": "year",
              "index": 0.0,
              "aggr": "sum"
            },
            "yAxis": {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          }
        },
        "editorMode": "ace/mode/scala",
        "title": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448277422735_835222886",
      "id": "20151123-111702_818647646",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 11:17:02 AM",
      "dateStarted": "Nov 24, 2015 5:42:46 PM",
      "dateFinished": "Nov 24, 2015 5:42:46 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Extraction de l\u0027année la plus productive (exercice optionnel)\n\nOn cherche à extraire du DataFrame la valeur de l\u0027année la plus productive en nombre d\u0027albums produits.\n\nTriez le DataFrame `countAlbumsPerYearDF` par la colonne contenant le nombre d\u0027albums. Utilisez un tri descendant.\n\nUtilisez `head` pour extraire l\u0027objet `Row` correspondant à la première ligne.\n\nUtilisez `getString` pour extraire la valeur souhaitée. Cf. [http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Row](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Row)",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448374854505_1675488180",
      "id": "20151124-142054_903895766",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eExtraction de l\u0027année la plus productive (exercice optionnel)\u003c/h1\u003e\n\u003cp\u003eOn cherche à extraire du DataFrame la valeur de l\u0027année la plus productive en nombre d\u0027albums produits.\u003c/p\u003e\n\u003cp\u003eTriez le DataFrame \u003ccode\u003ecountAlbumsPerYearDF\u003c/code\u003e par la colonne contenant le nombre d\u0027albums. Utilisez un tri descendant.\u003c/p\u003e\n\u003cp\u003eUtilisez \u003ccode\u003ehead\u003c/code\u003e pour extraire l\u0027objet \u003ccode\u003eRow\u003c/code\u003e correspondant à la première ligne.\u003c/p\u003e\n\u003cp\u003eUtilisez \u003ccode\u003egetString\u003c/code\u003e pour extraire la valeur souhaitée. Cf. \u003ca href\u003d\"http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Row\"\u003ehttp://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Row\u003c/a\u003e\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 2:20:54 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "l\u0027année la plus productive (en nombre d\u0027albums produits)",
      "text": "//TODO",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/scala",
        "title": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448299217240_-1731450036",
      "id": "20151123-172017_413578404",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 5:20:17 PM",
      "dateStarted": "Nov 24, 2015 5:42:46 PM",
      "dateFinished": "Nov 24, 2015 5:42:47 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Affichage des années les plus productives (exercice optionnel)\n\nOn cherche à afficher les 5 années les plus productives **sous forme de camembert**.\n\nTriez le DataFrame `countAlbumsPerYearDF` par la colonne contenant le nombre d\u0027albums. Utilisez un tri descendant.\n\nUtilisez `head` pour extraire les 5 premiers résultats.\n\nNous avons maintenant une liste d\u0027objets `Row`. Pour les afficher, deux solutions :\n\n## Solution 1 : utiliser le système d\u0027affichage de table de Zeppelin\n\nRéférez-vous à la documentation de Zeppelin pour l\u0027affichage d\u0027une table : [https://zeppelin.incubator.apache.org/docs/0.5.5-incubating/displaysystem/table.html](https://zeppelin.incubator.apache.org/docs/0.5.5-incubating/displaysystem/table.html)\n\nUtilisez `println` pour afficher `%table` puis la liste des champs.\n\nUtilisez ensuite `foreach` sur la liste de `Row` pour afficher chaque objet. Convertissez chaque objet `Row` en `String` avec `mkString` puis appelez `println` avec ce résultat.\n\n## Solution 2 : re-convertir la liste en DataFrame\n\nOn peut \"tricher\" et convertir la liste de `Row` en DataFrame.\n\nUtilisez `sqlContext.createDataFrame` pour créer un nouveau DataFrame. Vous devrez passer un `StructType` (le schéma) en deuxième argument. Utilisez `.schema` du DataFrame initial (le schéma est le même).\n\nUtilisez enfin `z.show` pour afficher le DataFrame.",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448376325500_-558697253",
      "id": "20151124-144525_334615246",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eAffichage des années les plus productives (exercice optionnel)\u003c/h1\u003e\n\u003cp\u003eOn cherche à afficher les 5 années les plus productives \u003cstrong\u003esous forme de camembert\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTriez le DataFrame \u003ccode\u003ecountAlbumsPerYearDF\u003c/code\u003e par la colonne contenant le nombre d\u0027albums. Utilisez un tri descendant.\u003c/p\u003e\n\u003cp\u003eUtilisez \u003ccode\u003ehead\u003c/code\u003e pour extraire les 5 premiers résultats.\u003c/p\u003e\n\u003cp\u003eNous avons maintenant une liste d\u0027objets \u003ccode\u003eRow\u003c/code\u003e. Pour les afficher, deux solutions :\u003c/p\u003e\n\u003ch2\u003eSolution 1 : utiliser le système d\u0027affichage de table de Zeppelin\u003c/h2\u003e\n\u003cp\u003eRéférez-vous à la documentation de Zeppelin pour l\u0027affichage d\u0027une table : \u003ca href\u003d\"https://zeppelin.incubator.apache.org/docs/0.5.5-incubating/displaysystem/table.html\"\u003ehttps://zeppelin.incubator.apache.org/docs/0.5.5-incubating/displaysystem/table.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eUtilisez \u003ccode\u003eprintln\u003c/code\u003e pour afficher \u003ccode\u003e%table\u003c/code\u003e puis la liste des champs.\u003c/p\u003e\n\u003cp\u003eUtilisez ensuite \u003ccode\u003eforeach\u003c/code\u003e sur la liste de \u003ccode\u003eRow\u003c/code\u003e pour afficher chaque objet. Convertissez chaque objet \u003ccode\u003eRow\u003c/code\u003e en \u003ccode\u003eString\u003c/code\u003e avec \u003ccode\u003emkString\u003c/code\u003e puis appelez \u003ccode\u003eprintln\u003c/code\u003e avec ce résultat.\u003c/p\u003e\n\u003ch2\u003eSolution 2 : re-convertir la liste en DataFrame\u003c/h2\u003e\n\u003cp\u003eOn peut \u0026ldquo;tricher\u0026rdquo; et convertir la liste de \u003ccode\u003eRow\u003c/code\u003e en DataFrame.\u003c/p\u003e\n\u003cp\u003eUtilisez \u003ccode\u003esqlContext.createDataFrame\u003c/code\u003e pour créer un nouveau DataFrame. Vous devrez passer un \u003ccode\u003eStructType\u003c/code\u003e (le schéma) en deuxième argument. Utilisez \u003ccode\u003e.schema\u003c/code\u003e du DataFrame initial (le schéma est le même).\u003c/p\u003e\n\u003cp\u003eUtilisez enfin \u003ccode\u003ez.show\u003c/code\u003e pour afficher le DataFrame.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 2:45:25 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Les 10 années les plus productives (Camembert)",
      "text": "//TODO",
      "dateUpdated": "Nov 24, 2015 5:42:44 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "pieChart",
          "height": 300.0,
          "optionOpen": false,
          "keys": [
            {
              "name": "year",
              "index": 0.0,
              "aggr": "sum"
            }
          ],
          "values": [
            {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          ],
          "groups": [],
          "scatter": {
            "xAxis": {
              "name": "year",
              "index": 0.0,
              "aggr": "sum"
            },
            "yAxis": {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          }
        },
        "editorMode": "ace/mode/scala",
        "title": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448301468370_2143390598",
      "id": "20151123-175748_866073835",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 5:57:48 PM",
      "dateStarted": "Nov 24, 2015 5:42:47 PM",
      "dateFinished": "Nov 24, 2015 5:42:47 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Distribution des groupes par pays\n\nOn souhaite afficher la distribution (le nombre) des groupes par pays.\n\nFiltrez le DataFrame `performersDF` pour ne garder que les éléments dont le type est `Group`.\n\nFiltrez ensuite pour ne garder que les éléments dont le pays n\u0027est pas `Unknown`.\n\nGroupez et comptez par pays.\n\nTriez ensuite ce résultat par ordre descendant du nombre de groupes par pays (vous devrez stocker le résultat précédent dans un DataFrame intermédiaire).\n\nUtilisez enfin `z.show` pour afficher le DataFrame final sous forme de tableau.",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448378444290_-1969642405",
      "id": "20151124-152044_962430423",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eDistribution des groupes par pays\u003c/h1\u003e\n\u003cp\u003eOn souhaite afficher la distribution (le nombre) des groupes par pays.\u003c/p\u003e\n\u003cp\u003eFiltrez le DataFrame \u003ccode\u003eperformersDF\u003c/code\u003e pour ne garder que les éléments dont le type est \u003ccode\u003eGroup\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFiltrez ensuite pour ne garder que les éléments dont le pays n\u0027est pas \u003ccode\u003eUnknown\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eGroupez et comptez par pays.\u003c/p\u003e\n\u003cp\u003eTriez ensuite ce résultat par ordre descendant du nombre de groupes par pays (vous devrez stocker le résultat précédent dans un DataFrame intermédiaire).\u003c/p\u003e\n\u003cp\u003eUtilisez enfin \u003ccode\u003ez.show\u003c/code\u003e pour afficher le DataFrame final sous forme de tableau.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 3:20:44 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "distribution des groupes par pays",
      "text": "//TODO",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [
            {
              "name": "Country",
              "index": 0.0,
              "aggr": "sum"
            }
          ],
          "values": [
            {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          ],
          "groups": [],
          "scatter": {
            "xAxis": {
              "name": "Country",
              "index": 0.0,
              "aggr": "sum"
            },
            "yAxis": {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          }
        },
        "title": false,
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448301693758_-1151489545",
      "id": "20151123-180133_400045425",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 6:01:33 PM",
      "dateStarted": "Nov 24, 2015 5:42:47 PM",
      "dateFinished": "Nov 24, 2015 5:42:47 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Distribution des groupes par style musical\n\nOn souhaite afficher la distribution (le nombre) des groupes par style musical.\n\nFiltrez le DataFrame `performersDF` pour ne garder que les éléments dont le type est `Group`.\n\nUtilisez `explode` pour décomposer la colonne `styles` en plusieurs lignes. Vous pouvez utiliser la fonction `splitStyles` pour transformer une chaine de caractère (représentant une liste de styles) en une liste de chaine de caractères (chacune représentant un style unique).\n\nSupprimez la colonne `styles` qui n\u0027est plus nécessaire.\n\nStockez ce résultat dans un Dataframe intermédiaire : `groupsExplodedByStyleDF`.\n\nFiltrez ce nouveau Dataframe pour supprimer les lignes dont le style est `Unknown`.\n\nGroupez et comptez enfin par style.\n\nUtilisez enfin `z.show` pour afficher le DataFrame final sous forme de camembert.",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/scala",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448378892673_1436967040",
      "id": "20151124-152812_1069711329",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eDistribution des groupes par style musical\u003c/h1\u003e\n\u003cp\u003eOn souhaite afficher la distribution (le nombre) des groupes par style musical.\u003c/p\u003e\n\u003cp\u003eFiltrez le DataFrame \u003ccode\u003eperformersDF\u003c/code\u003e pour ne garder que les éléments dont le type est \u003ccode\u003eGroup\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eUtilisez \u003ccode\u003eexplode\u003c/code\u003e pour décomposer la colonne \u003ccode\u003estyles\u003c/code\u003e en plusieurs lignes. Vous pouvez utiliser la fonction \u003ccode\u003esplitStyles\u003c/code\u003e pour transformer une chaine de caractère (représentant une liste de styles) en une liste de chaine de caractères (chacune représentant un style unique).\u003c/p\u003e\n\u003cp\u003eSupprimez la colonne \u003ccode\u003estyles\u003c/code\u003e qui n\u0027est plus nécessaire.\u003c/p\u003e\n\u003cp\u003eStockez ce résultat dans un Dataframe intermédiaire : \u003ccode\u003egroupsExplodedByStyleDF\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFiltrez ce nouveau Dataframe pour supprimer les lignes dont le style est \u003ccode\u003eUnknown\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eGroupez et comptez enfin par style.\u003c/p\u003e\n\u003cp\u003eUtilisez enfin \u003ccode\u003ez.show\u003c/code\u003e pour afficher le DataFrame final sous forme de camembert.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 3:28:12 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:45 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Distribution Des Groupes Par style",
      "text": "def splitStyles(styles: String) \u003d  styles.stripPrefix(\"[\").stripSuffix(\"]\").replaceAll(\"\u0027\",\"\").split(\",\")\n\n//TODO",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "pieChart",
          "height": 300.0,
          "optionOpen": false,
          "keys": [
            {
              "name": "style",
              "index": 0.0,
              "aggr": "sum"
            }
          ],
          "values": [
            {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          ],
          "groups": [],
          "scatter": {
            "xAxis": {
              "name": "style",
              "index": 0.0,
              "aggr": "sum"
            },
            "yAxis": {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          }
        },
        "editorMode": "ace/mode/scala",
        "title": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448302591658_-1088887677",
      "id": "20151123-181631_1506284640",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": "splitStyles: (styles: String)Array[String]\n"
      },
      "dateCreated": "Nov 23, 2015 6:16:31 PM",
      "dateStarted": "Nov 24, 2015 5:42:47 PM",
      "dateFinished": "Nov 24, 2015 5:42:47 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Groupes de Rock qui ont publié un album en 1990\n\nOn souhaite afficher uniquement les groupes qui ont publié un album en 1990. L\u0027information de l\u0027année (1990) se trouve dans le DataFrame `albumsDF` tandis que celle des styles (Rock) se trouve dans le DataFrame `performersDF` (ou `groupsExplodedByStyleDF` de l\u0027exercice précédent). Il faut donc réaliser une jointure entre deux DataFrames.\n\nFiltrez le DataFrame `groupsExplodedByStyleDF` (de l\u0027exercice précédent) pour ne garder que les groupes dont le style est `Rock`. Stockez ce DataFrame dans une variable `performersRockDF`.\n\nFiltrez `albumsDF` pour ne conserver que les albums produits en 1990. Stockez ce DataFrame dans une variable `albums1990DF`.\n\nUtilisez `join` pour réaliser la jointure entre `albums1990DF` et `performersRockDF`.\n\nConservez uniquement la colonne `name` puis triez les résultats dans l\u0027ordre alphabétique de cette colonne.\n\nSupprimez les doublons.\n\nAffichez enfin le résultat.",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448379327791_-210110185",
      "id": "20151124-153527_534021930",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eGroupes de Rock qui ont publié un album en 1990\u003c/h1\u003e\n\u003cp\u003eOn souhaite afficher uniquement les groupes qui ont publié un album en 1990. L\u0027information de l\u0027année (1990) se trouve dans le DataFrame \u003ccode\u003ealbumsDF\u003c/code\u003e tandis que celle des styles (Rock) se trouve dans le DataFrame \u003ccode\u003eperformersDF\u003c/code\u003e (ou \u003ccode\u003egroupsExplodedByStyleDF\u003c/code\u003e de l\u0027exercice précédent). Il faut donc réaliser une jointure entre deux DataFrames.\u003c/p\u003e\n\u003cp\u003eFiltrez le DataFrame \u003ccode\u003egroupsExplodedByStyleDF\u003c/code\u003e (de l\u0027exercice précédent) pour ne garder que les groupes dont le style est \u003ccode\u003eRock\u003c/code\u003e. Stockez ce DataFrame dans une variable \u003ccode\u003eperformersRockDF\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFiltrez \u003ccode\u003ealbumsDF\u003c/code\u003e pour ne conserver que les albums produits en 1990. Stockez ce DataFrame dans une variable \u003ccode\u003ealbums1990DF\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eUtilisez \u003ccode\u003ejoin\u003c/code\u003e pour réaliser la jointure entre \u003ccode\u003ealbums1990DF\u003c/code\u003e et \u003ccode\u003eperformersRockDF\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eConservez uniquement la colonne \u003ccode\u003ename\u003c/code\u003e puis triez les résultats dans l\u0027ordre alphabétique de cette colonne.\u003c/p\u003e\n\u003cp\u003eSupprimez les doublons.\u003c/p\u003e\n\u003cp\u003eAffichez enfin le résultat.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 3:35:27 PM",
      "dateStarted": "Nov 24, 2015 5:42:45 PM",
      "dateFinished": "Nov 24, 2015 5:42:46 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "artistes qui ont publié un album en 1990",
      "text": "//TODO",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [
            {
              "name": "name",
              "index": 0.0,
              "aggr": "sum"
            }
          ],
          "values": [],
          "groups": [],
          "scatter": {
            "xAxis": {
              "name": "name",
              "index": 0.0,
              "aggr": "sum"
            }
          }
        },
        "title": false,
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448302551420_1184178177",
      "id": "20151123-181551_1208191694",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 6:15:51 PM",
      "dateStarted": "Nov 24, 2015 5:42:47 PM",
      "dateFinished": "Nov 24, 2015 5:42:48 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Nombre d\u0027albums par décade\n\nOn souhaite maintenant afficher le nombre d\u0027albums produits par décade. Il faut pour cela utiliser une UDF (User Defined Function).\n\nLa fonction `decade` calcule la décade à partir d\u0027une année (ex : \"2015\" devient \"2010\").\n\nFiltrez le Dataframe `albumsDF` pour ne conserver que les albums produits après 1900 (on supprime les *outliers*).\n\nAppliquez l\u0027UDF `decade` sur la colonne `year` pour produire une colonne `decade`.\n\nGroupez et comptez par `decade`, puis affichez le résultat **sous forme d\u0027histogramme**.",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448381569110_-1093923857",
      "id": "20151124-161249_765092003",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eNombre d\u0027albums par décade\u003c/h1\u003e\n\u003cp\u003eOn souhaite maintenant afficher le nombre d\u0027albums produits par décade. Il faut pour cela utiliser une UDF (User Defined Function).\u003c/p\u003e\n\u003cp\u003eLa fonction \u003ccode\u003edecade\u003c/code\u003e calcule la décade à partir d\u0027une année (ex : \u0026ldquo;2015\u0026rdquo; devient \u0026ldquo;2010\u0026rdquo;).\u003c/p\u003e\n\u003cp\u003eFiltrez le Dataframe \u003ccode\u003ealbumsDF\u003c/code\u003e pour ne conserver que les albums produits après 1900 (on supprime les \u003cem\u003eoutliers\u003c/em\u003e).\u003c/p\u003e\n\u003cp\u003eAppliquez l\u0027UDF \u003ccode\u003edecade\u003c/code\u003e sur la colonne \u003ccode\u003eyear\u003c/code\u003e pour produire une colonne \u003ccode\u003edecade\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eGroupez et comptez par \u003ccode\u003edecade\u003c/code\u003e, puis affichez le résultat \u003cstrong\u003esous forme d\u0027histogramme\u003c/strong\u003e.\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 4:12:49 PM",
      "dateStarted": "Nov 24, 2015 5:42:46 PM",
      "dateFinished": "Nov 24, 2015 5:42:46 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "title": "Nombre D\u0027albums Par décade (Histogramme)",
      "text": "def decade(year: Int) \u003d (year / 10) * 10\n\n//TODO",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "pieChart",
          "height": 300.0,
          "optionOpen": false,
          "keys": [
            {
              "name": "decade",
              "index": 0.0,
              "aggr": "sum"
            }
          ],
          "values": [
            {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          ],
          "groups": [],
          "scatter": {
            "xAxis": {
              "name": "decade",
              "index": 0.0,
              "aggr": "sum"
            },
            "yAxis": {
              "name": "count",
              "index": 1.0,
              "aggr": "sum"
            }
          }
        },
        "title": false,
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448303975471_-1997536528",
      "id": "20151123-183935_575648006",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": "decade: (year: Int)Int\n"
      },
      "dateCreated": "Nov 23, 2015 6:39:35 PM",
      "dateStarted": "Nov 24, 2015 5:42:48 PM",
      "dateFinished": "Nov 24, 2015 5:42:48 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "%md\n# Affichage de la relation entre l\u0027année de publication des albums et l\u0027année de création des groupes\n\nOn cherche à afficher, sur un graphe, l\u0027année moyenne de création des groupes en fonction de l\u0027année de publication des albums.\n\nFiltrez `performersDF` pour ne conserver que les éléments de type `Group` et dont l\u0027année de création est supérieure à 1950. Stockez ce résultat.\n\nFiltrez `albumsDF` pour ne conserver que les albums l\u0027année de publication est supérieure à 1950. Stockez ce résultat.\n\nEffectuez la jointure entre les deux résultats intermédiaires.\n\nGroupez par l\u0027année de publication de l\u0027album (`year`) et aggrégez par valeur moyenne de l\u0027année de création du groupe (`born`).\n\nAffichez ce résultat sous forme de graphique (en points).",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448384400159_1347949885",
      "id": "20151124-170000_1175254201",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003ch1\u003eAffichage de la relation entre l\u0027année de publication des albums et l\u0027année de création des groupes\u003c/h1\u003e\n\u003cp\u003eOn cherche à afficher, sur un graphe, l\u0027année moyenne de création des groupes en fonction de l\u0027année de publication des albums.\u003c/p\u003e\n\u003cp\u003eFiltrez \u003ccode\u003eperformersDF\u003c/code\u003e pour ne conserver que les éléments de type \u003ccode\u003eGroup\u003c/code\u003e et dont l\u0027année de création est supérieure à 1950. Stockez ce résultat.\u003c/p\u003e\n\u003cp\u003eFiltrez \u003ccode\u003ealbumsDF\u003c/code\u003e pour ne conserver que les albums l\u0027année de publication est supérieure à 1950. Stockez ce résultat.\u003c/p\u003e\n\u003cp\u003eEffectuez la jointure entre les deux résultats intermédiaires.\u003c/p\u003e\n\u003cp\u003eGroupez par l\u0027année de publication de l\u0027album (\u003ccode\u003eyear\u003c/code\u003e) et aggrégez par valeur moyenne de l\u0027année de création du groupe (\u003ccode\u003eborn\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eAffichez ce résultat sous forme de graphique (en points).\u003c/p\u003e\n"
      },
      "dateCreated": "Nov 24, 2015 5:00:00 PM",
      "dateStarted": "Nov 24, 2015 5:42:46 PM",
      "dateFinished": "Nov 24, 2015 5:42:46 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "//TODO",
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "scatterChart",
          "height": 300.0,
          "optionOpen": true,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448304365481_1782820629",
      "id": "20151123-184605_1548085747",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Nov 23, 2015 6:46:05 PM",
      "dateStarted": "Nov 24, 2015 5:42:48 PM",
      "dateFinished": "Nov 24, 2015 5:42:48 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "dateUpdated": "Nov 24, 2015 5:42:45 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1448383888597_-63841614",
      "id": "20151124-165128_1563221520",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT"
      },
      "dateCreated": "Nov 24, 2015 4:51:28 PM",
      "dateStarted": "Nov 24, 2015 5:42:48 PM",
      "dateFinished": "Nov 24, 2015 5:42:48 PM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "Music",
  "id": "2B4TXEETP",
  "angularObjects": {
    "2B6CZ7P9R": [],
    "2B4H1Z7FY": [],
    "2B7A4G9PU": [],
    "2B74MBX43": [],
    "2B6CVXYG3": [],
    "2B4KEF8PV": [],
    "2B74PNRBA": [],
    "2B56NG2XE": [],
    "2B5ARRP57": [],
    "2B72FS11B": [],
    "2B6RKF2EE": [],
    "2B6Q1S4ZS": [],
    "2B6J56JPK": []
  },
  "config": {
    "looknfeel": "default"
  },
  "info": {}
}